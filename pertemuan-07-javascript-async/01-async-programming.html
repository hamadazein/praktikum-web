<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript Async Programming & APIs</title>
  <script src="../back-button.js" defer></script>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      .demo-section {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        margin: 20px 0;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      }

      .code-block {
        background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
        color: #e2e8f0;
        padding: 25px;
        border-radius: 15px;
        margin: 20px 0;
        font-family: "Consolas", "Monaco", "Courier New", monospace;
        font-size: 14px;
        border-left: 5px solid #4299e1;
        overflow-x: auto;
        position: relative;
      }

      .api-response {
        background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
        color: #e2e8f0;
        padding: 20px;
        border-radius: 12px;
        margin: 15px 0;
        font-family: "Consolas", monospace;
        white-space: pre-wrap;
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #4a5568;
      }

      .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .btn-async {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        border: none;
        border-radius: 25px;
        color: white;
        font-weight: 600;
        padding: 12px 25px;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .btn-async:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(79, 172, 254, 0.3);
        color: white;
      }

      .btn-async:disabled {
        opacity: 0.7;
        transform: none;
      }

      .async-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 15px;
        padding: 25px;
        margin: 15px 0;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      .weather-card {
        background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
        color: white;
        border-radius: 20px;
        padding: 25px;
        text-align: center;
        margin: 15px 0;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
      }

      .crypto-card {
        background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
        color: white;
        border-radius: 15px;
        padding: 20px;
        margin: 10px 0;
        transition: all 0.3s ease;
      }

      .crypto-card:hover {
        transform: scale(1.02);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      }

      .progress-bar-animated {
        background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
        animation: progress-animation 2s ease-in-out infinite;
      }

      @keyframes progress-animation {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      .promise-state {
        padding: 15px;
        border-radius: 10px;
        margin: 10px 0;
        font-weight: 600;
        text-align: center;
      }

      .promise-pending {
        background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);
        color: white;
      }

      .promise-resolved {
        background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
        color: white;
      }

      .promise-rejected {
        background: linear-gradient(135deg, #d63031 0%, #e84393 100%);
        color: white;
      }

      .error-display {
        background: linear-gradient(135deg, #ff7675 0%, #fd79a8 100%);
        color: white;
        padding: 20px;
        border-radius: 12px;
        margin: 15px 0;
      }

      .success-display {
        background: linear-gradient(135deg, #00b894 0%, #55efc4 100%);
        color: white;
        padding: 20px;
        border-radius: 12px;
        margin: 15px 0;
      }

      .timeline {
        position: relative;
        padding-left: 30px;
      }

      .timeline::before {
        content: "";
        position: absolute;
        left: 15px;
        top: 0;
        bottom: 0;
        width: 2px;
        background: linear-gradient(to bottom, #4facfe, #00f2fe);
      }

      .timeline-item {
        position: relative;
        margin-bottom: 20px;
        background: white;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      }

      .timeline-item::before {
        content: "";
        position: absolute;
        left: -22px;
        top: 20px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #4facfe;
        border: 3px solid white;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }
    </style>
  </head>
  <body>
    <div class="container py-4">
      <header class="text-center mb-5">
        <h1 class="display-4 text-white mb-3">
          ⚡ Pemrograman Asinkron JavaScript
        </h1>
        <p class="lead text-white">
          Promises, Async/Await, Fetch API & Data Real-time
        </p>
        <!-- Alert Penjelasan Pemrograman Asinkron -->
        <div class="alert alert-info mt-4 text-start">
          <h6>
            <i class="fas fa-info-circle me-2"></i>Apa itu Pemrograman Asinkron?
          </h6>
          <p class="mb-1">
            <strong>Pemrograman Asinkron</strong> memungkinkan kode JavaScript
            menjalankan operasi yang membutuhkan waktu (seperti mengambil data
            dari server) tanpa memblokir eksekusi kode lainnya.
          </p>
          <p class="mb-0">
            Ini sangat penting untuk menciptakan aplikasi web yang responsif dan
            tidak "freeze" saat memproses data.
          </p>
        </div>
      </header>

      <!-- PROMISES FUNDAMENTALS -->
      <section class="demo-section">
        <h2 class="text-primary mb-4">
          <i class="fas fa-hourglass-half me-2"></i>Memahami Promises
        </h2>

        <!-- Alert Penjelasan Promises -->
        <div class="alert alert-warning mb-4">
          <h6><i class="fas fa-lightbulb me-2"></i>Apa itu Promise?</h6>
          <p class="mb-1">
            <strong>Promise</strong> adalah objek JavaScript yang mewakili hasil
            akhir dari operasi asinkron. Promise memiliki 3 status:
          </p>
          <ul class="mb-1">
            <li><strong>Pending:</strong> Operasi sedang berjalan</li>
            <li><strong>Resolved (Fulfilled):</strong> Operasi berhasil</li>
            <li><strong>Rejected:</strong> Operasi gagal</li>
          </ul>
          <p class="mb-0">
            Promise membantu mengatasi "callback hell" dan membuat kode asinkron
            lebih mudah dibaca.
          </p>
        </div>

        <div class="row">
          <div class="col-md-6">
            <h4>Demo Status Promise</h4>
            <div class="d-grid gap-2">
              <button
                class="btn btn-async"
                onclick="demonstratePromisePending()"
              >
                <i class="fas fa-clock me-2"></i>Promise Pending
              </button>
              <button
                class="btn btn-async"
                onclick="demonstratePromiseResolved()"
              >
                <i class="fas fa-check me-2"></i>Promise Resolved
              </button>
              <button
                class="btn btn-async"
                onclick="demonstratePromiseRejected()"
              >
                <i class="fas fa-times me-2"></i>Promise Rejected
              </button>
              <button
                class="btn btn-async"
                onclick="demonstratePromiseChaining()"
              >
                <i class="fas fa-link me-2"></i>Promise Chaining
              </button>
            </div>

            <div class="mt-4">
              <h5>Status Promise:</h5>
              <div id="promiseState" class="promise-state promise-pending">
                Siap untuk demo promises
              </div>
            </div>
          </div>

          <div class="col-md-6">
            <h4>Hasil Promise</h4>
            <div id="promiseResults" class="api-response">
              Belum ada promise yang dijalankan
            </div>

            <div class="mt-3">
              <h6>Timeline Eksekusi</h6>
              <div id="promiseTimeline" class="timeline">
                <div class="timeline-item">
                  <small class="text-muted">Siap untuk memulai...</small>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="code-block">
          // Promise Basic Syntax const myPromise = new Promise((resolve,
          reject) => { // Asynchronous operation setTimeout(() => { const
          success = Math.random() > 0.5; if (success) { resolve("Operation
          successful!"); } else { reject("Operation failed!"); } }, 2000); });
          // Using the promise myPromise .then(result => {
          console.log("Success:", result); }) .catch(error => {
          console.log("Error:", error); }) .finally(() => { console.log("Promise
          completed"); }); // Promise chaining fetch('/api/user') .then(response
          => response.json()) .then(user => fetch(`/api/posts/${user.id}`))
          .then(response => response.json()) .then(posts => console.log("User
          posts:", posts)) .catch(error => console.error("Error:", error));
        </div>
      </section>

      <!-- ASYNC/AWAIT -->
      <section class="demo-section">
        <h2 class="text-primary mb-4">
          <i class="fas fa-magic me-2"></i>Sintaks Async/Await
        </h2>

        <!-- Alert Penjelasan Async/Await -->
        <div class="alert alert-success mb-4">
          <h6>
            <i class="fas fa-star me-2"></i>Mengapa Async/Await Lebih Baik?
          </h6>
          <p class="mb-1">
            <strong>Async/Await</strong> adalah cara yang lebih mudah untuk
            bekerja dengan Promise. Keuntungannya:
          </p>
          <ul class="mb-1">
            <li>
              <strong>Lebih mudah dibaca:</strong> Kode terlihat seperti kode
              sinkron biasa
            </li>
            <li>
              <strong>Error handling lebih sederhana:</strong> Bisa menggunakan
              try-catch
            </li>
            <li>
              <strong>Debugging lebih mudah:</strong> Stack trace lebih jelas
            </li>
          </ul>
          <p class="mb-0">
            Async/Await adalah syntactic sugar untuk Promise - di balik layar
            tetap menggunakan Promise!
          </p>
        </div>

        <div class="row">
          <div class="col-md-6">
            <h4>Demo Fungsi Async</h4>
            <div class="mb-3">
              <label for="delayInput" class="form-label">Delay (detik)</label>
              <input
                type="number"
                class="form-control"
                id="delayInput"
                value="2"
                min="1"
                max="10"
              />
            </div>
            <div class="d-grid gap-2">
              <button
                class="btn btn-async"
                onclick="demonstrateAsyncAwait()"
                id="asyncBtn"
              >
                <i class="fas fa-play me-2"></i>Jalankan Fungsi Async
              </button>
              <button
                class="btn btn-async"
                onclick="demonstrateParallelAsync()"
              >
                <i class="fas fa-bolt me-2"></i>Eksekusi Paralel
              </button>
              <button
                class="btn btn-async"
                onclick="demonstrateErrorHandling()"
              >
                <i class="fas fa-bug me-2"></i>Penanganan Error
              </button>
            </div>

            <div class="mt-4">
              <h6>Progress</h6>
              <div class="progress" style="height: 25px">
                <div
                  id="asyncProgress"
                  class="progress-bar progress-bar-animated"
                  style="width: 0%"
                >
                  0%
                </div>
              </div>
            </div>
          </div>

          <div class="col-md-6">
            <h4>Log Eksekusi</h4>
            <div id="asyncResults" class="api-response">
              Klik tombol untuk memulai eksekusi async
            </div>

            <div class="mt-3">
              <button
                class="btn btn-outline-secondary btn-sm"
                onclick="clearAsyncLog()"
              >
                <i class="fas fa-trash me-1"></i>Hapus Log
              </button>
            </div>
          </div>
        </div>

        <div class="code-block">
          // Async/Await Basic Syntax async function fetchUserData(userId) { try
          { console.log("Fetching user data..."); // Wait for user data const
          userResponse = await fetch(`/api/users/${userId}`); const user = await
          userResponse.json(); // Wait for user posts const postsResponse =
          await fetch(`/api/posts?userId=${userId}`); const posts = await
          postsResponse.json(); return { user, posts }; } catch (error) {
          console.error("Error fetching data:", error); throw error; } } //
          Parallel execution with Promise.all async function
          fetchMultipleUsers(userIds) { try { const promises = userIds.map(id =>
          fetch(`/api/users/${id}`)); const responses = await
          Promise.all(promises); // Convert all responses to JSON in parallel
          const users = await Promise.all( responses.map(response =>
          response.json()) ); return users; } catch (error) {
          console.error("Error in parallel fetch:", error); } } // Error
          handling with async/await async function robustDataFetch() { try {
          const data = await fetchUserData(123); console.log("Success:", data);
          } catch (error) { if (error.name === 'NetworkError') {
          console.log("Network error, retrying..."); // Retry logic } else {
          console.log("Other error:", error.message); } } finally {
          console.log("Cleanup operations"); } }
        </div>
      </section>

      <!-- FETCH API -->
      <section class="demo-section">
        <h2 class="text-primary mb-4">
          <i class="fas fa-cloud-download-alt me-2"></i>Fetch API & HTTP
          Requests
        </h2>

        <!-- Alert Penjelasan Fetch API -->
        <div class="alert alert-primary mb-4">
          <h6><i class="fas fa-globe me-2"></i>Apa itu Fetch API?</h6>
          <p class="mb-1">
            <strong>Fetch API</strong> adalah cara modern untuk melakukan HTTP
            requests di JavaScript. Keuntungannya:
          </p>
          <ul class="mb-1">
            <li>
              <strong>Promise-based:</strong> Mudah digunakan dengan async/await
            </li>
            <li>
              <strong>Lebih powerful:</strong> Mendukung berbagai jenis request
              (GET, POST, PUT, DELETE)
            </li>
            <li>
              <strong>Built-in:</strong> Tidak perlu library tambahan seperti
              jQuery
            </li>
          </ul>
          <p class="mb-0">
            Fetch API menggantikan XMLHttpRequest yang lebih kompleks dan sulit
            digunakan.
          </p>
        </div>

        <div class="row">
          <div class="col-md-6">
            <div class="async-card">
              <h4 class="mb-3">
                <i class="fas fa-users me-2"></i>JSONPlaceholder API
              </h4>

              <div class="d-grid gap-2 mb-3">
                <button class="btn btn-light" onclick="fetchUsers()">
                  <i class="fas fa-user-friends me-2"></i>Ambil Data Users
                </button>
                <button class="btn btn-light" onclick="fetchPosts()">
                  <i class="fas fa-file-text me-2"></i>Ambil Data Posts
                </button>
                <button class="btn btn-light" onclick="fetchPhotos()">
                  <i class="fas fa-images me-2"></i>Ambil Data Photos
                </button>
              </div>

              <div class="input-group mb-3">
                <input
                  type="number"
                  class="form-control"
                  id="userIdInput"
                  placeholder="ID User (1-10)"
                  min="1"
                  max="10"
                  value="1"
                />
                <button class="btn btn-light" onclick="fetchSpecificUser()">
                  <i class="fas fa-search"></i>
                </button>
              </div>

              <div class="input-group">
                <input
                  type="text"
                  class="form-control"
                  id="postTitleInput"
                  placeholder="Judul post baru"
                />
                <button class="btn btn-light" onclick="createPost()">
                  <i class="fas fa-plus"></i>
                </button>
              </div>
            </div>
          </div>

          <div class="col-md-6">
            <div class="async-card">
              <h4 class="mb-3">
                <i class="fas fa-thermometer-half me-2"></i>Weather API
              </h4>

              <div class="input-group mb-3">
                <input
                  type="text"
                  class="form-control"
                  id="cityInput"
                  placeholder="Masukkan nama kota"
                  value="Jakarta"
                />
                <button class="btn btn-light" onclick="fetchWeather()">
                  <i class="fas fa-cloud-sun me-2"></i>Ambil Cuaca
                </button>
              </div>

              <div class="d-grid gap-2">
                <button class="btn btn-light" onclick="getCurrentLocation()">
                  <i class="fas fa-map-marker-alt me-2"></i>Gunakan Lokasi Saya
                </button>
                <button class="btn btn-light" onclick="fetchMultipleCities()">
                  <i class="fas fa-globe me-2"></i>Beberapa Kota
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="row mt-4">
          <div class="col-12">
            <h4>Respons API</h4>
            <div id="fetchResults" class="api-response">
              Belum ada panggilan API yang dibuat
            </div>
          </div>
        </div>

        <div class="code-block">
          // Fetch API Basic Usage async function fetchData(url) { try { const
          response = await fetch(url); // Check if response is ok if
          (!response.ok) { throw new Error(`HTTP error! status:
          ${response.status}`); } const data = await response.json(); return
          data; } catch (error) { console.error("Fetch error:", error); throw
          error; } } // POST request with fetch async function
          createUser(userData) { try { const response = await
          fetch('/api/users', { method: 'POST', headers: { 'Content-Type':
          'application/json', 'Authorization': 'Bearer ' + token }, body:
          JSON.stringify(userData) }); if (!response.ok) { throw new
          Error('Failed to create user'); } return await response.json(); }
          catch (error) { console.error("Create user error:", error); } } //
          Request with timeout async function fetchWithTimeout(url, timeout =
          5000) { const controller = new AbortController(); const timeoutId =
          setTimeout(() => controller.abort(), timeout); try { const response =
          await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId); return response; } catch (error) { if
          (error.name === 'AbortError') { throw new Error('Request timeout'); }
          throw error; } }
        </div>
      </section>

      <!-- REAL-TIME DATA -->
      <section class="demo-section">
        <h2 class="text-primary mb-4">
          <i class="fas fa-chart-line me-2"></i>Data Real-time & APIs
        </h2>

        <!-- Alert Penjelasan Real-time Data -->
        <div class="alert alert-info mb-4">
          <h6>
            <i class="fas fa-broadcast-tower me-2"></i>Mengapa Data Real-time
            Penting?
          </h6>
          <p class="mb-1">
            <strong>Data Real-time</strong> memungkinkan aplikasi menampilkan
            informasi yang selalu terbaru tanpa reload halaman:
          </p>
          <ul class="mb-1">
            <li>
              <strong>User Experience:</strong> Informasi selalu up-to-date
            </li>
            <li>
              <strong>Interaktivitas:</strong> Aplikasi terasa lebih hidup dan
              responsif
            </li>
            <li>
              <strong>Efisiensi:</strong> Tidak perlu refresh halaman secara
              manual
            </li>
          </ul>
          <p class="mb-0">
            Contoh: harga saham, cuaca, notifikasi, chat, dashboard monitoring.
          </p>
        </div>

        <div class="row">
          <div class="col-md-8">
            <div id="weatherDisplay" class="weather-card" style="display: none">
              <div class="row align-items-center">
                <div class="col-md-6">
                  <h3 id="weatherCity">Nama Kota</h3>
                  <p id="weatherDescription" class="mb-1">Deskripsi Cuaca</p>
                  <div class="h2" id="weatherTemp">--°C</div>
                </div>
                <div class="col-md-6">
                  <div class="row text-center">
                    <div class="col-6">
                      <div class="h5" id="weatherHumidity">--%</div>
                      <small>Kelembaban</small>
                    </div>
                    <div class="col-6">
                      <div class="h5" id="weatherWind">-- km/j</div>
                      <small>Kecepatan Angin</small>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div class="mt-4">
              <h4>Harga Cryptocurrency</h4>
              <div class="d-flex gap-2 mb-3">
                <button class="btn btn-async" onclick="fetchCryptoPrices()">
                  <i class="fas fa-coins me-2"></i>Ambil Harga Crypto
                </button>
                <button
                  class="btn btn-async"
                  onclick="startCryptoUpdates()"
                  id="cryptoUpdateBtn"
                >
                  <i class="fas fa-play me-2"></i>Mulai Update Live
                </button>
                <button
                  class="btn btn-outline-secondary"
                  onclick="stopCryptoUpdates()"
                >
                  <i class="fas fa-stop me-2"></i>Hentikan Update
                </button>
              </div>
              <div id="cryptoDisplay" class="row">
                <!-- Kartu crypto akan dimasukkan di sini -->
              </div>
            </div>
          </div>

          <div class="col-md-4">
            <h4>Generator User Acak</h4>
            <button
              class="btn btn-async w-100 mb-3"
              onclick="fetchRandomUser()"
            >
              <i class="fas fa-user-plus me-2"></i>Generate User Acak
            </button>

            <div id="randomUserDisplay" class="text-center">
              <p class="text-muted">Klik untuk generate user acak</p>
            </div>

            <div class="mt-4">
              <h5>Quote Hari Ini</h5>
              <button
                class="btn btn-async w-100 mb-3"
                onclick="fetchRandomQuote()"
              >
                <i class="fas fa-quote-left me-2"></i>Ambil Inspirasi
              </button>

              <div id="quoteDisplay" class="p-3 bg-light rounded">
                <p class="text-muted text-center">
                  Klik untuk mendapatkan quote inspiratif
                </p>
              </div>
            </div>
          </div>
        </div>

        <div class="code-block">
          // Real-time data polling class DataPoller { constructor(url, interval
          = 5000) { this.url = url; this.interval = interval; this.polling =
          false; this.timeoutId = null; } async start(callback) { this.polling =
          true; const poll = async () => { if (!this.polling) return; try {
          const response = await fetch(this.url); const data = await
          response.json(); callback(data); } catch (error) {
          console.error("Polling error:", error); } if (this.polling) {
          this.timeoutId = setTimeout(poll, this.interval); } }; await poll();
          // Initial call } stop() { this.polling = false; if (this.timeoutId) {
          clearTimeout(this.timeoutId); } } } // WebSocket for real-time
          communication class RealtimeConnection { constructor(url) { this.url =
          url; this.ws = null; this.reconnectAttempts = 0;
          this.maxReconnectAttempts = 5; } connect() { this.ws = new
          WebSocket(this.url); this.ws.onopen = () => { console.log("WebSocket
          connected"); this.reconnectAttempts = 0; }; this.ws.onmessage =
          (event) => { const data = JSON.parse(event.data);
          this.handleMessage(data); }; this.ws.onclose = () => {
          console.log("WebSocket disconnected"); this.attemptReconnect(); };
          this.ws.onerror = (error) => { console.error("WebSocket error:",
          error); }; } attemptReconnect() { if (this.reconnectAttempts <
          this.maxReconnectAttempts) { this.reconnectAttempts++; setTimeout(()
          => this.connect(), 5000); } } send(data) { if (this.ws.readyState ===
          WebSocket.OPEN) { this.ws.send(JSON.stringify(data)); } } }
        </div>
      </section>

      <!-- ERROR HANDLING & RETRY LOGIC -->
      <section class="demo-section">
        <h2 class="text-primary mb-4">
          <i class="fas fa-shield-alt me-2"></i>Error Handling & Retry Logic
        </h2>

        <!-- Alert Penjelasan Error Handling -->
        <div class="alert alert-danger mb-4">
          <h6>
            <i class="fas fa-exclamation-triangle me-2"></i>Mengapa Error
            Handling Penting?
          </h6>
          <p class="mb-1">
            Dalam pemrograman asinkron, banyak hal bisa salah: koneksi terputus,
            server error, timeout. <strong>Error Handling</strong> yang baik:
          </p>
          <ul class="mb-1">
            <li>
              <strong>Mencegah aplikasi crash:</strong> Tangani error dengan
              graceful
            </li>
            <li>
              <strong>Retry Logic:</strong> Coba lagi jika error bersifat
              sementara
            </li>
            <li>
              <strong>User Experience:</strong> Berikan feedback yang informatif
            </li>
          </ul>
          <p class="mb-0">
            Try-catch dengan async/await dan .catch() dengan Promise adalah dua
            cara utama menangani error.
          </p>
        </div>

        <div class="row">
          <div class="col-md-6">
            <h4>Mekanisme Retry</h4>
            <div class="d-grid gap-2">
              <button class="btn btn-async" onclick="demonstrateRetryLogic()">
                <i class="fas fa-redo me-2"></i>Retry saat Gagal
              </button>
              <button
                class="btn btn-async"
                onclick="demonstrateExponentialBackoff()"
              >
                <i class="fas fa-hourglass me-2"></i>Exponential Backoff
              </button>
              <button
                class="btn btn-async"
                onclick="demonstrateCircuitBreaker()"
              >
                <i class="fas fa-power-off me-2"></i>Circuit Breaker
              </button>
              <button class="btn btn-async" onclick="demonstrateTimeout()">
                <i class="fas fa-clock me-2"></i>Request Timeout
              </button>
            </div>

            <div class="mt-4">
              <h6>Kontrol Simulasi</h6>
              <div class="form-check">
                <input
                  class="form-check-input"
                  type="checkbox"
                  id="simulateErrors"
                />
                <label class="form-check-label" for="simulateErrors">
                  Simulasikan Network Errors
                </label>
              </div>
              <div class="form-check">
                <input
                  class="form-check-input"
                  type="checkbox"
                  id="simulateSlowNetwork"
                />
                <label class="form-check-label" for="simulateSlowNetwork">
                  Simulasikan Jaringan Lambat
                </label>
              </div>
            </div>
          </div>

          <div class="col-md-6">
            <h4>Log Error Handling</h4>
            <div id="errorHandlingLog" class="api-response">
              Belum ada operasi yang dilakukan
            </div>

            <div class="mt-3">
              <button
                class="btn btn-outline-secondary btn-sm"
                onclick="clearErrorLog()"
              >
                <i class="fas fa-eraser me-1"></i>Hapus Log
              </button>
            </div>
          </div>
        </div>

        <div class="code-block">
          // Retry logic with exponential backoff async function
          fetchWithRetry(url, options = {}, maxRetries = 3) { let lastError; for
          (let attempt = 1; attempt <= maxRetries; attempt++) { try { const
          response = await fetch(url, options); if (!response.ok) { throw new
          Error(`HTTP ${response.status}: ${response.statusText}`); } return
          response; } catch (error) { lastError = error; if (attempt ===
          maxRetries) { throw error; } // Exponential backoff: 1s, 2s, 4s, 8s...
          const delay = Math.pow(2, attempt - 1) * 1000; console.log(`Attempt
          ${attempt} failed. Retrying in ${delay}ms...`); await new
          Promise(resolve => setTimeout(resolve, delay)); } } throw lastError; }
          // Circuit breaker pattern class CircuitBreaker {
          constructor(threshold = 5, timeout = 60000, monitor = false) {
          this.threshold = threshold; this.timeout = timeout; this.monitor =
          monitor; this.failureCount = 0; this.lastFailureTime = null;
          this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN } async call(fn) {
          if (this.state === 'OPEN') { if (this.canAttemptReset()) { this.state
          = 'HALF_OPEN'; } else { throw new Error('Circuit breaker is OPEN'); }
          } try { const result = await fn(); this.onSuccess(); return result; }
          catch (error) { this.onFailure(); throw error; } } onSuccess() {
          this.failureCount = 0; this.state = 'CLOSED'; } onFailure() {
          this.failureCount++; this.lastFailureTime = Date.now(); if
          (this.failureCount >= this.threshold) { this.state = 'OPEN'; } }
          canAttemptReset() { return Date.now() - this.lastFailureTime >=
          this.timeout; } } // Request timeout with AbortController async
          function fetchWithTimeout(url, timeoutMs = 5000) { const controller =
          new AbortController(); const timeoutId = setTimeout(() =>
          controller.abort(), timeoutMs); try { const response = await
          fetch(url, { signal: controller.signal }); clearTimeout(timeoutId);
          return response; } catch (error) { clearTimeout(timeoutId); if
          (error.name === 'AbortError') { throw new Error(`Request timeout after
          ${timeoutMs}ms`); } throw error; } }
        </div>
      </section>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      // =============================================================================
      // GLOBAL VARIABLES
      // =============================================================================
      let cryptoUpdateInterval = null;
      let promiseExecutionCount = 0;
      let asyncLogCount = 0;

      // =============================================================================
      // PROMISE DEMONSTRATIONS
      // =============================================================================
      function demonstratePromisePending() {
        updatePromiseState("pending", "Promise is pending...");
        clearPromiseTimeline();
        addTimelineItem("Promise created and pending");

        const promise = new Promise((resolve) => {
          setTimeout(() => {
            resolve("Promise resolved after 3 seconds");
            updatePromiseState("resolved", "Promise completed successfully!");
            addTimelineItem("Promise resolved with data");
          }, 3000);
        });

        promise.then((result) => {
          updatePromiseResults(result);
        });
      }

      function demonstratePromiseResolved() {
        updatePromiseState("pending", "Creating resolved promise...");
        clearPromiseTimeline();
        addTimelineItem("Creating promise that will resolve immediately");

        const promise = Promise.resolve("This promise resolves immediately");

        promise.then((result) => {
          updatePromiseState("resolved", "Promise resolved successfully!");
          updatePromiseResults(result);
          addTimelineItem("Promise resolved: " + result);
        });
      }

      function demonstratePromiseRejected() {
        updatePromiseState("pending", "Creating rejected promise...");
        clearPromiseTimeline();
        addTimelineItem("Creating promise that will reject");

        const promise = Promise.reject("This promise rejects immediately");

        promise.catch((error) => {
          updatePromiseState("rejected", "Promise was rejected!");
          updatePromiseResults("Error: " + error);
          addTimelineItem("Promise rejected: " + error);
        });
      }

      function demonstratePromiseChaining() {
        updatePromiseState("pending", "Starting promise chain...");
        clearPromiseTimeline();
        addTimelineItem("Starting promise chain");

        Promise.resolve(10)
          .then((value) => {
            addTimelineItem(`Step 1: Received ${value}`);
            return value * 2;
          })
          .then((value) => {
            addTimelineItem(`Step 2: Multiplied to ${value}`);
            return value + 5;
          })
          .then((value) => {
            addTimelineItem(`Step 3: Added 5 to get ${value}`);
            return `Final result: ${value}`;
          })
          .then((result) => {
            updatePromiseState("resolved", "Chain completed!");
            updatePromiseResults(result);
            addTimelineItem("Chain completed: " + result);
          })
          .catch((error) => {
            updatePromiseState("rejected", "Chain failed!");
            updatePromiseResults("Error in chain: " + error);
          });
      }

      function updatePromiseState(state, message) {
        const stateDiv = document.getElementById("promiseState");
        stateDiv.className = `promise-state promise-${state}`;
        stateDiv.textContent = message;
      }

      function updatePromiseResults(result) {
        document.getElementById(
          "promiseResults"
        ).textContent = `Execution #${++promiseExecutionCount}\n\nResult: ${result}\n\nTimestamp: ${new Date().toLocaleTimeString()}`;
      }

      function clearPromiseTimeline() {
        document.getElementById("promiseTimeline").innerHTML = "";
      }

      function addTimelineItem(message) {
        const timeline = document.getElementById("promiseTimeline");
        const item = document.createElement("div");
        item.className = "timeline-item";
        item.innerHTML = `
                <strong>${new Date().toLocaleTimeString()}</strong><br>
                <small>${message}</small>
            `;
        timeline.appendChild(item);
      }

      // =============================================================================
      // ASYNC/AWAIT DEMONSTRATIONS
      // =============================================================================
      async function demonstrateAsyncAwait() {
        const btn = document.getElementById("asyncBtn");
        const delay =
          parseInt(document.getElementById("delayInput").value) * 1000;

        btn.disabled = true;
        btn.innerHTML = '<span class="loading-spinner me-2"></span>Running...';

        clearAsyncLog();
        updateProgress(0);

        try {
          logAsync("Starting async function...");

          for (let i = 1; i <= 5; i++) {
            await sleep(delay / 5);
            updateProgress(i * 20);
            logAsync(`Step ${i}/5 completed`);
          }

          logAsync("Async function completed successfully!");
        } catch (error) {
          logAsync("Error in async function: " + error.message);
        } finally {
          btn.disabled = false;
          btn.innerHTML = '<i class="fas fa-play me-2"></i>Run Async Function';
        }
      }

      async function demonstrateParallelAsync() {
        clearAsyncLog();
        logAsync("Starting parallel execution...");

        const startTime = Date.now();

        try {
          // Sequential execution
          logAsync("Sequential execution:");
          const seq1 = await simulateAsyncTask("Task A", 1000);
          const seq2 = await simulateAsyncTask("Task B", 1500);
          const seq3 = await simulateAsyncTask("Task C", 800);
          const sequentialTime = Date.now() - startTime;

          logAsync(`Sequential results: ${seq1}, ${seq2}, ${seq3}`);
          logAsync(`Sequential time: ${sequentialTime}ms`);

          // Parallel execution
          logAsync("\nParallel execution:");
          const parallelStart = Date.now();

          const [par1, par2, par3] = await Promise.all([
            simulateAsyncTask("Task A", 1000),
            simulateAsyncTask("Task B", 1500),
            simulateAsyncTask("Task C", 800),
          ]);

          const parallelTime = Date.now() - parallelStart;

          logAsync(`Parallel results: ${par1}, ${par2}, ${par3}`);
          logAsync(`Parallel time: ${parallelTime}ms`);
          logAsync(`Time saved: ${sequentialTime - parallelTime}ms`);
        } catch (error) {
          logAsync("Error in parallel execution: " + error.message);
        }
      }

      async function demonstrateErrorHandling() {
        clearAsyncLog();
        logAsync("Demonstrating error handling...");

        try {
          await simulateAsyncTask("Successful task", 500);

          // This will throw an error
          await simulateAsyncTask("Failing task", 500, true);
        } catch (error) {
          logAsync(`Caught error: ${error.message}`);

          // Recovery logic
          try {
            logAsync("Attempting recovery...");
            await simulateAsyncTask("Recovery task", 300);
            logAsync("Recovery successful!");
          } catch (recoveryError) {
            logAsync(`Recovery failed: ${recoveryError.message}`);
          }
        } finally {
          logAsync("Cleanup operations completed");
        }
      }

      async function simulateAsyncTask(taskName, delay, shouldFail = false) {
        logAsync(`Starting ${taskName}...`);
        await sleep(delay);

        if (shouldFail) {
          throw new Error(`${taskName} failed`);
        }

        logAsync(`${taskName} completed`);
        return `${taskName} result`;
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function updateProgress(percentage) {
        const progressBar = document.getElementById("asyncProgress");
        progressBar.style.width = percentage + "%";
        progressBar.textContent = percentage + "%";
      }

      function logAsync(message) {
        const results = document.getElementById("asyncResults");
        const timestamp = new Date().toLocaleTimeString();
        results.textContent += `[${timestamp}] ${message}\n`;
        results.scrollTop = results.scrollHeight;
      }

      function clearAsyncLog() {
        document.getElementById("asyncResults").textContent = "";
        asyncLogCount = 0;
      }

      // =============================================================================
      // FETCH API DEMONSTRATIONS
      // =============================================================================
      async function fetchUsers() {
        updateFetchResults("Fetching users...");

        try {
          const response = await fetch(
            "https://jsonplaceholder.typicode.com/users"
          );
          const users = await response.json();

          const formattedUsers = users.map((user) => ({
            id: user.id,
            name: user.name,
            email: user.email,
            company: user.company.name,
          }));

          updateFetchResults(JSON.stringify(formattedUsers, null, 2));
        } catch (error) {
          updateFetchResults(`Error: ${error.message}`);
        }
      }

      async function fetchPosts() {
        updateFetchResults("Fetching posts...");

        try {
          const response = await fetch(
            "https://jsonplaceholder.typicode.com/posts?_limit=5"
          );
          const posts = await response.json();

          updateFetchResults(JSON.stringify(posts, null, 2));
        } catch (error) {
          updateFetchResults(`Error: ${error.message}`);
        }
      }

      async function fetchPhotos() {
        updateFetchResults("Fetching photos...");

        try {
          const response = await fetch(
            "https://jsonplaceholder.typicode.com/photos?_limit=3"
          );
          const photos = await response.json();

          const formattedPhotos = photos.map((photo) => ({
            id: photo.id,
            title: photo.title,
            url: photo.url,
            thumbnailUrl: photo.thumbnailUrl,
          }));

          updateFetchResults(JSON.stringify(formattedPhotos, null, 2));
        } catch (error) {
          updateFetchResults(`Error: ${error.message}`);
        }
      }

      async function fetchSpecificUser() {
        const userId = document.getElementById("userIdInput").value;
        updateFetchResults(`Fetching user ${userId}...`);

        try {
          const response = await fetch(
            `https://jsonplaceholder.typicode.com/users/${userId}`
          );
          const user = await response.json();

          updateFetchResults(JSON.stringify(user, null, 2));
        } catch (error) {
          updateFetchResults(`Error: ${error.message}`);
        }
      }

      async function createPost() {
        const title = document.getElementById("postTitleInput").value;
        if (!title) {
          alert("Please enter a post title");
          return;
        }

        updateFetchResults("Creating new post...");

        try {
          const response = await fetch(
            "https://jsonplaceholder.typicode.com/posts",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                title: title,
                body: "This is a demo post created via fetch API",
                userId: 1,
              }),
            }
          );

          const newPost = await response.json();
          updateFetchResults(JSON.stringify(newPost, null, 2));

          document.getElementById("postTitleInput").value = "";
        } catch (error) {
          updateFetchResults(`Error: ${error.message}`);
        }
      }

      // Weather API functions
      async function fetchWeather() {
        const city = document.getElementById("cityInput").value;
        if (!city) {
          alert("Please enter a city name");
          return;
        }

        updateFetchResults("Fetching weather data...");

        try {
          // Using OpenWeatherMap API (you'd need an API key for real implementation)
          // For demo, we'll simulate weather data
          await sleep(1000);

          const mockWeatherData = {
            city: city,
            temperature: Math.floor(Math.random() * 35) + 10,
            description: ["Sunny", "Cloudy", "Rainy", "Partly Cloudy"][
              Math.floor(Math.random() * 4)
            ],
            humidity: Math.floor(Math.random() * 50) + 30,
            windSpeed: Math.floor(Math.random() * 20) + 5,
          };

          displayWeather(mockWeatherData);
          updateFetchResults(JSON.stringify(mockWeatherData, null, 2));
        } catch (error) {
          updateFetchResults(`Error: ${error.message}`);
        }
      }

      function displayWeather(data) {
        document.getElementById("weatherCity").textContent = data.city;
        document.getElementById("weatherDescription").textContent =
          data.description;
        document.getElementById(
          "weatherTemp"
        ).textContent = `${data.temperature}°C`;
        document.getElementById(
          "weatherHumidity"
        ).textContent = `${data.humidity}%`;
        document.getElementById(
          "weatherWind"
        ).textContent = `${data.windSpeed} km/h`;

        document.getElementById("weatherDisplay").style.display = "block";
      }

      async function getCurrentLocation() {
        updateFetchResults("Getting current location...");

        if (!navigator.geolocation) {
          updateFetchResults("Geolocation is not supported by this browser");
          return;
        }

        navigator.geolocation.getCurrentPosition(
          async (position) => {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;

            updateFetchResults(`Location: ${lat}, ${lon}\nFetching weather...`);

            // Simulate reverse geocoding and weather fetch
            await sleep(1500);

            const mockData = {
              city: "Your Location",
              temperature: Math.floor(Math.random() * 35) + 10,
              description: "Current Weather",
              humidity: Math.floor(Math.random() * 50) + 30,
              windSpeed: Math.floor(Math.random() * 20) + 5,
              coordinates: { lat, lon },
            };

            displayWeather(mockData);
            updateFetchResults(JSON.stringify(mockData, null, 2));
          },
          (error) => {
            updateFetchResults(`Geolocation error: ${error.message}`);
          }
        );
      }

      async function fetchMultipleCities() {
        const cities = [
          "Jakarta",
          "Singapore",
          "Bangkok",
          "Manila",
          "Kuala Lumpur",
        ];
        updateFetchResults("Fetching weather for multiple cities...");

        try {
          const promises = cities.map(async (city) => {
            await sleep(Math.random() * 1000 + 500);
            return {
              city,
              temperature: Math.floor(Math.random() * 35) + 10,
              humidity: Math.floor(Math.random() * 50) + 30,
            };
          });

          const results = await Promise.all(promises);
          updateFetchResults(JSON.stringify(results, null, 2));
        } catch (error) {
          updateFetchResults(`Error: ${error.message}`);
        }
      }

      // =============================================================================
      // REAL-TIME DATA FUNCTIONS
      // =============================================================================
      async function fetchCryptoPrices() {
        updateFetchResults("Fetching cryptocurrency prices...");

        try {
          // Simulate crypto price data
          await sleep(1000);

          const cryptoData = [
            {
              symbol: "BTC",
              name: "Bitcoin",
              price: 45000 + Math.random() * 10000,
              change: (Math.random() - 0.5) * 10,
            },
            {
              symbol: "ETH",
              name: "Ethereum",
              price: 3000 + Math.random() * 1000,
              change: (Math.random() - 0.5) * 8,
            },
            {
              symbol: "BNB",
              name: "Binance Coin",
              price: 400 + Math.random() * 100,
              change: (Math.random() - 0.5) * 6,
            },
            {
              symbol: "ADA",
              name: "Cardano",
              price: 1 + Math.random() * 2,
              change: (Math.random() - 0.5) * 15,
            },
          ];

          displayCryptoPrices(cryptoData);
          updateFetchResults(JSON.stringify(cryptoData, null, 2));
        } catch (error) {
          updateFetchResults(`Error: ${error.message}`);
        }
      }

      function displayCryptoPrices(cryptoData) {
        const container = document.getElementById("cryptoDisplay");
        container.innerHTML = "";

        cryptoData.forEach((crypto) => {
          const changeClass =
            crypto.change >= 0 ? "text-success" : "text-danger";
          const changeIcon =
            crypto.change >= 0 ? "fa-arrow-up" : "fa-arrow-down";

          const card = document.createElement("div");
          card.className = "col-md-6 mb-2";
          card.innerHTML = `
                    <div class="crypto-card">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <h6 class="mb-0">${crypto.symbol}</h6>
                                <small>${crypto.name}</small>
                            </div>
                            <div class="text-end">
                                <div class="h6 mb-0">$${crypto.price.toFixed(
                                  2
                                )}</div>
                                <small class="${changeClass}">
                                    <i class="fas ${changeIcon}"></i>
                                    ${Math.abs(crypto.change).toFixed(2)}%
                                </small>
                            </div>
                        </div>
                    </div>
                `;
          container.appendChild(card);
        });
      }

      function startCryptoUpdates() {
        const btn = document.getElementById("cryptoUpdateBtn");

        if (cryptoUpdateInterval) {
          stopCryptoUpdates();
          return;
        }

        btn.innerHTML = '<i class="fas fa-pause me-2"></i>Pause Updates';
        btn.classList.add("btn-warning");
        btn.classList.remove("btn-async");

        fetchCryptoPrices(); // Initial fetch

        cryptoUpdateInterval = setInterval(() => {
          fetchCryptoPrices();
        }, 5000);
      }

      function stopCryptoUpdates() {
        const btn = document.getElementById("cryptoUpdateBtn");

        if (cryptoUpdateInterval) {
          clearInterval(cryptoUpdateInterval);
          cryptoUpdateInterval = null;
        }

        btn.innerHTML = '<i class="fas fa-play me-2"></i>Start Live Updates';
        btn.classList.remove("btn-warning");
        btn.classList.add("btn-async");
      }

      async function fetchRandomUser() {
        updateFetchResults("Generating random user...");

        try {
          const response = await fetch("https://randomuser.me/api/");
          const data = await response.json();
          const user = data.results[0];

          const userData = {
            name: `${user.name.first} ${user.name.last}`,
            email: user.email,
            phone: user.phone,
            location: `${user.location.city}, ${user.location.country}`,
            picture: user.picture.large,
          };

          displayRandomUser(userData);
          updateFetchResults(JSON.stringify(userData, null, 2));
        } catch (error) {
          updateFetchResults(`Error: ${error.message}`);
        }
      }

      function displayRandomUser(user) {
        document.getElementById("randomUserDisplay").innerHTML = `
                <img src="${user.picture}" alt="User" class="rounded-circle mb-3" width="100" height="100">
                <h6>${user.name}</h6>
                <p class="small mb-1">${user.email}</p>
                <p class="small mb-1">${user.phone}</p>
                <p class="small text-muted">${user.location}</p>
            `;
      }

      async function fetchRandomQuote() {
        updateFetchResults("Fetching inspirational quote...");

        try {
          // Simulate quote API
          await sleep(800);

          const quotes = [
            {
              text: "The only way to do great work is to love what you do.",
              author: "Steve Jobs",
            },
            {
              text: "Innovation distinguishes between a leader and a follower.",
              author: "Steve Jobs",
            },
            {
              text: "Life is what happens to you while you're busy making other plans.",
              author: "John Lennon",
            },
            {
              text: "The future belongs to those who believe in the beauty of their dreams.",
              author: "Eleanor Roosevelt",
            },
            {
              text: "The only impossible journey is the one you never begin.",
              author: "Tony Robbins",
            },
          ];

          const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];

          document.getElementById("quoteDisplay").innerHTML = `
                    <blockquote class="blockquote text-center">
                        <p class="mb-0">"${randomQuote.text}"</p>
                        <footer class="blockquote-footer mt-2">
                            <cite title="Source Title">${randomQuote.author}</cite>
                        </footer>
                    </blockquote>
                `;

          updateFetchResults(JSON.stringify(randomQuote, null, 2));
        } catch (error) {
          updateFetchResults(`Error: ${error.message}`);
        }
      }

      function updateFetchResults(content) {
        document.getElementById("fetchResults").textContent = content;
      }

      // =============================================================================
      // ERROR HANDLING DEMONSTRATIONS
      // =============================================================================
      async function demonstrateRetryLogic() {
        clearErrorLog();
        logError("Starting retry logic demonstration...");

        const maxRetries = 3;
        let attempt = 1;

        while (attempt <= maxRetries) {
          try {
            logError(`Attempt ${attempt}/${maxRetries}`);

            // Simulate API call that might fail
            await simulateUnreliableAPI();

            logError("✅ Request succeeded!");
            break;
          } catch (error) {
            logError(`❌ Attempt ${attempt} failed: ${error.message}`);

            if (attempt === maxRetries) {
              logError("🚫 All retry attempts exhausted");
              throw error;
            }

            const delay = 1000 * attempt; // Linear backoff
            logError(`⏳ Waiting ${delay}ms before retry...`);
            await sleep(delay);

            attempt++;
          }
        }
      }

      async function demonstrateExponentialBackoff() {
        clearErrorLog();
        logError("Starting exponential backoff demonstration...");

        const maxRetries = 4;

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            logError(`Attempt ${attempt}/${maxRetries}`);
            await simulateUnreliableAPI();
            logError("✅ Request succeeded!");
            return;
          } catch (error) {
            logError(`❌ Attempt ${attempt} failed: ${error.message}`);

            if (attempt === maxRetries) {
              logError("🚫 All retry attempts exhausted");
              return;
            }

            // Exponential backoff: 1s, 2s, 4s, 8s
            const delay = Math.pow(2, attempt - 1) * 1000;
            logError(`⏳ Exponential backoff: ${delay}ms`);
            await sleep(delay);
          }
        }
      }

      async function demonstrateCircuitBreaker() {
        clearErrorLog();
        logError("Starting circuit breaker demonstration...");

        // Simple circuit breaker implementation
        let failureCount = 0;
        const threshold = 3;
        let circuitOpen = false;
        let lastFailureTime = 0;
        const timeout = 5000; // 5 seconds

        for (let i = 1; i <= 8; i++) {
          try {
            // Check if circuit should be reset
            if (circuitOpen && Date.now() - lastFailureTime > timeout) {
              circuitOpen = false;
              failureCount = 0;
              logError("🔄 Circuit breaker reset - attempting half-open state");
            }

            if (circuitOpen) {
              logError(
                `🚫 Request ${i}: Circuit breaker is OPEN - request blocked`
              );
              continue;
            }

            logError(`🔄 Request ${i}: Circuit is CLOSED - attempting request`);
            await simulateUnreliableAPI();

            // Success - reset failure count
            failureCount = 0;
            logError(`✅ Request ${i}: Success!`);
          } catch (error) {
            failureCount++;
            lastFailureTime = Date.now();
            logError(
              `❌ Request ${i}: Failed (${failureCount}/${threshold} failures)`
            );

            if (failureCount >= threshold) {
              circuitOpen = true;
              logError("🚨 Circuit breaker OPENED - blocking future requests");
            }
          }

          await sleep(800);
        }
      }

      async function demonstrateTimeout() {
        clearErrorLog();
        logError("Starting timeout demonstration...");

        const timeoutMs = 3000;

        try {
          logError(`Setting timeout to ${timeoutMs}ms`);

          const controller = new AbortController();
          const timeoutId = setTimeout(() => {
            controller.abort();
            logError("⏰ Request timed out!");
          }, timeoutMs);

          // Simulate slow API call
          await new Promise((resolve, reject) => {
            const delay = 5000; // 5 seconds - will timeout

            logError(`Starting request with ${delay}ms delay...`);

            const requestId = setTimeout(resolve, delay);

            controller.signal.addEventListener("abort", () => {
              clearTimeout(requestId);
              reject(new Error("Request timeout"));
            });
          });

          clearTimeout(timeoutId);
          logError("✅ Request completed within timeout");
        } catch (error) {
          logError(`❌ ${error.message}`);
        }
      }

      async function simulateUnreliableAPI() {
        const simulateErrors =
          document.getElementById("simulateErrors").checked;
        const simulateSlowNetwork = document.getElementById(
          "simulateSlowNetwork"
        ).checked;

        // Add delay for slow network simulation
        const delay = simulateSlowNetwork ? 2000 + Math.random() * 3000 : 500;
        await sleep(delay);

        // Simulate random failures
        if (simulateErrors && Math.random() < 0.6) {
          const errors = [
            "Network timeout",
            "Server error 500",
            "Connection refused",
            "DNS lookup failed",
            "Rate limit exceeded",
          ];
          throw new Error(errors[Math.floor(Math.random() * errors.length)]);
        }

        return "API call successful";
      }

      function logError(message) {
        const log = document.getElementById("errorHandlingLog");
        const timestamp = new Date().toLocaleTimeString();
        log.textContent += `[${timestamp}] ${message}\n`;
        log.scrollTop = log.scrollHeight;
      }

      function clearErrorLog() {
        document.getElementById("errorHandlingLog").textContent = "";
      }

      // =============================================================================
      // INITIALIZATION
      // =============================================================================
      document.addEventListener("DOMContentLoaded", function () {
        console.log("⚡ Async Programming tutorial loaded!");
        console.log(
          "Features: Promises, Async/Await, Fetch API, Error Handling"
        );

        // Set default values
        document.getElementById("delayInput").value = 2;
        document.getElementById("cityInput").value = "Jakarta";
        document.getElementById("userIdInput").value = 1;
      });

      // Cleanup on page unload
      window.addEventListener("beforeunload", function () {
        if (cryptoUpdateInterval) {
          clearInterval(cryptoUpdateInterval);
        }
      });
    </script>
  </body>
</html>
